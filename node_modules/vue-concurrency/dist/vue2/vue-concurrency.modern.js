import{computed as e,reactive as n,watch as s,onUnmounted as r,onServerPrefetch as i,getCurrentInstance as t}from"@vue/composition-api";import c from"caf";function o(e){return new Promise(n=>{const r=s(e,e=>{null!=e&&(n(e),r&&r())},{immediate:!0})})}function u(n,s){return s?function(n,s,r){return e(()=>n().filter(e=>e[s]))}(()=>n()._instances,s):e(()=>[])}function a(n){return e(()=>n().length)}function l(n){return e(()=>{const e=n();return e[e.length-1]})}function d(n){return e(()=>n()[0])}function f(e){return n(e)}function _(){const e={},n=new Promise((n,s)=>{e.resolve=n,e.reject=s});return e.promise=n,e}function p(e){let n="General";e._isDropping&&(n="Drop"),e._isEnqueuing&&(n="Enqueue"),e._isRestartable&&(n="Restartable"),e._isKeepingLatest&&(n="KeepLatest");let s=n+" Task";"General"!==n&&(s=`${s} with maxConcurrency ${e._maxConcurrency}`);const r=e._instances.map(e=>{let n;e.isSuccessful?n="🍏":e.isRunning||e.isEnqueued?n="🍊":(e.isError||e.isCanceled||e.isDropped)&&(n="🔴");const{status:s,value:r,error:i}=e;return{status:`${n} ${s}`,value:r,error:i}});console.log("🚦 "+s),console.table(r)}function g(e){return"test"===process.env.NODE_ENV?Promise.resolve():new Promise(n=>setTimeout(n,e))}function h(e,n){return new e.CancelToken(e=>{n.pr.catch(n=>{"cancel"===n&&e()})})}function m(e){return E(function*(n,...s){return e(n,...s)})}function E(n){const s=f({_isRestartable:!1,_isDropping:!1,_isEnqueuing:!1,_isKeepingLatest:!1,_maxConcurrency:1,_hasConcurrency:e(()=>s._isRestartable||s._isDropping||s._isEnqueuing||s._isKeepingLatest),isIdle:e(()=>!s.isRunning),isRunning:e(()=>!!s._instances.find(e=>e.isRunning)),isError:e(()=>!(!s.last||!s.last.isError)),_instances:[],_successfulInstances:u(()=>s,"isSuccessful"),_runningInstances:u(()=>s,"isRunning"),_enqueuedInstances:u(()=>s,"isEnqueued"),_notDroppedInstances:u(()=>s,"isNotDropped"),_activeInstances:u(()=>s,"isActive"),performCount:a(()=>s._instances),last:l(()=>s._notDroppedInstances),lastSuccessful:l(()=>s._successfulInstances),firstEnqueued:d(()=>s._enqueuedInstances),cancelAll(){s._instances.forEach(e=>{try{e.isDropped||e.isFinished||e.cancel()}catch(e){if("cancel"!==e)throw e}})},perform(...r){const i={enqueue:!1,drop:!1};s._hasConcurrency&&(e=>e._runningInstances.length>=e._maxConcurrency)(s)&&(s._isDropping&&(i.drop=!0),s._isRestartable&&(e=>{const n=e._activeInstances[0];n&&n.cancel()})(s),s._isKeepingLatest&&(e=>{e._enqueuedInstances.forEach(e=>{e.isEnqueued=!1,e.isDropped=!0})})(s),(s._isEnqueuing||s._isKeepingLatest)&&(i.enqueue=!0));const t=function(n,s,r){const i=f({id:r.id,isDropped:!1,isEnqueued:!1,hasStarted:!1,isRunning:!1,isFinished:!1,isCanceling:!1,isCanceled:e(()=>i.isCanceling&&i.isFinished),isActive:e(()=>i.isRunning&&!i.isCanceling),isSuccessful:!1,isNotDropped:e(()=>!i.isDropped),isError:e(()=>!!i.error),status:e(()=>{const e=[[i.isRunning,"running"],[i.isEnqueued,"enqueued"],[i.isCanceled,"canceled"],[i.isCanceling,"canceling"],[i.isDropped,"dropped"],[i.isError,"error"],[i.isSuccessful,"success"]].find(([e])=>e);return e&&e[1]}),error:null,value:null,cancel(){i.isCanceling=!0,i.isEnqueued&&(i.isFinished=!0),i.isEnqueued=!1,i.token&&i.token.abort("cancel")},canceledOn:e=>(e.pr.catch(e=>{i.cancel()}),i),_run(){!function(e,n,s,r){const i=new c.cancelToken,t=c(n,i);function o(){e.isRunning=!1,e.isFinished=!0}e.token=i,e.hasStarted=!0,e.isRunning=!0,e.isEnqueued=!1,t.call(e,i,...s).then(n=>{e.value=n,e.isSuccessful=!0,o(),e._deferredObject.resolve(n),r.onFinish(e)}).catch(n=>{"cancel"!==n&&(e.error=n),o(),e._shouldThrow&&e._deferredObject.reject(n),r.onFinish(e)})}(i,n,s,r)},_handled:!0,_deferredObject:_(),_shouldThrow:!1,then:(e,n)=>(i._shouldThrow=!0,i._deferredObject.promise.then(e,n)),catch:e=>(i._shouldThrow=!0,i._deferredObject.promise.catch(e)),finally:e=>(i._shouldThrow=!0,i._deferredObject.promise.finally(e))}),{modifiers:t}=r;return t.drop?i.isDropped=!0:t.enqueue?i.isEnqueued=!0:i._run(),i}(n,r,{modifiers:i,onFinish:()=>function(e){if(e._isEnqueuing||e._isKeepingLatest){const{firstEnqueued:n}=e;n&&n._run()}}(s),id:s._instances.length+1});return s._instances=[...s._instances,t],t},clear(){this.cancelAll(),this._instances=[]},restartable:()=>(s._resetModifierFlags(),s._isRestartable=!0,s),drop:()=>(s._resetModifierFlags(),s._isDropping=!0,s),enqueue:()=>(s._resetModifierFlags(),s._isEnqueuing=!0,s),keepLatest:()=>(s._resetModifierFlags(),s._isKeepingLatest=!0,s),_resetModifierFlags(){s._isKeepingLatest=!1,s._isRestartable=!1,s._isEnqueuing=!1,s._isDropping=!1},maxConcurrency:e=>(s._maxConcurrency=e,s)});return r(()=>{s._instances&&s.cancelAll()}),s}function q(e,...n){return E(function*(s,...r){let i=yield e.perform(...r).canceledOn(s);for(let e of n)i=yield e.perform(i).canceledOn(s);return i})}function y(...e){return E(function*(n,...s){const r=e.map(e=>e.perform(...s).canceledOn(n));return yield Promise.all(r)})}function C(...e){return E(function*(n,...s){const r=[];for(let i of e)r.push(yield i.perform(...s).canceledOn(n));return r})}const v=()=>"undefined"==typeof window;function w(e){e._deferredObject.promise=e.isError?Promise.reject(e.error):Promise.resolve(e.value),e.cancel=()=>{},e.canceledOn=()=>e,e._run=()=>{},e.then=(...n)=>e._deferredObject.promise.then(...n),e.catch=(...n)=>e._deferredObject.promise.catch(...n),e.finally=(...n)=>e._deferredObject.promise.finally(...n)}function b(e,n){if(v()){const s=n.perform();return i(async()=>{try{await s,R(e,n)}catch(e){}}),s}const[s]=D(e,n).reverse();return s||n.perform()}function R(n,s){const{$root:r}=t(),i=r&&r.context&&r.context.nuxtState;if(!i)throw new Error("Could not access $root.context.nuxtState");i.vueConcurrency||(i.vueConcurrency={}),i.vueConcurrency[n]=e(()=>({instances:s._instances}))}function D(e,n){const s=function(e){if(!O())throw Error("Could not access  window.__NUXT__");return O().vueConcurrency[e].value}(e);return s&&(n._instances=s.instances||[],n._instances.forEach(w),function(e){delete O().vueConcurrency[e]}(e)),n._instances}function O(){return window.__NUXT__}function j(e,n){v()?R(e,n):D(e,n)}function F(s){const r=Object.values(s),i=n({isRunning:e(()=>!!r.find(e=>e.isRunning)),isIdle:e(()=>!i.isRunning),...s});return i}export{h as getCancelToken,p as printTask,g as timeout,m as useAsyncTask,y as useParallelTask,q as usePipeTask,j as useSSRPersistance,C as useSequentialTask,E as useTask,F as useTaskGroup,b as useTaskPrefetch,o as waitForValue};
//# sourceMappingURL=vue-concurrency.modern.js.map
