{"version":3,"file":"vue-concurrency.modern.js","sources":["../../src/utils/general.ts","../../src/Task.ts","../../src/TaskInstance.ts","../../src/wrap-utils.ts","../../src/utils/ssr-utils.ts","../../src/utils/api3.ts","../../src/TaskGroup.ts"],"sourcesContent":["import { computed, Ref, watch, reactive } from \"./api\";\nimport useTask, { Task } from \"../Task\";\nimport { TaskInstance } from \"../TaskInstance\";\nimport { AbortSignalWithPromise } from \"../types/index\";\n\nexport function waitForValue<T = any>(cb: () => T): Promise<T> {\n  return new Promise((resolve) => {\n    const stop = watch(cb, value => {\n      if (value !== undefined && value !== null) {\n        resolve(value);\n        stop && stop();\n      }\n    }, { immediate: true });\n  });\n}\n\nexport const reachedMaxConcurrency = (task: Task<any, any>): boolean =>\n  task._runningInstances.length >= task._maxConcurrency;\n\nexport const cancelFirstRunning = (task: Task<any, any>): void => {\n  const firstRunningInstance = task._activeInstances[0];\n  if (firstRunningInstance) {\n    firstRunningInstance.cancel();\n  }\n};\n\nexport const dropEnqueued = (task: Task<any, any>): void => {\n  task._enqueuedInstances.forEach((instance) => {\n    instance.isEnqueued = false;\n    instance.isDropped = true;\n  });\n};\n\ntype BooleanKeys<T> = {\n  [k in keyof T]: T[k] extends boolean ? k : never;\n}[keyof T];\n\nexport function filteredInstances(\n  cb: () => Task<any, any>,\n  key: BooleanKeys<TaskInstance<any>>\n) {\n  if (!key) {\n    return computed(() => []);\n  }\n\n  return computedFilterBy(() => cb()._instances, key);\n}\n\nfunction computedFilterBy<T>(cb: () => T[], key: keyof T, value?: any) {\n  return computed(() => {\n    const collection = cb();\n    return collection.filter((item) => {\n      const curr = item[key];\n      if (value) {\n        return curr === value;\n      }\n\n      return curr;\n    });\n  });\n}\n\nexport function computedLength(cb: () => any[]): Readonly<Ref<number>> {\n  return computed(() => {\n    const arr = cb();\n    return arr.length;\n  });\n}\n\nexport function computedLastOf<T>(cb: () => readonly T[]): Ref<T | undefined> {\n  return computed(() => {\n    const collection = cb();\n    return collection[collection.length - 1];\n  });\n}\n\nexport function computedFirstOf<T>(\n  cb: () => readonly T[]\n): Readonly<Ref<T | undefined>> {\n  return computed(() => {\n    const collection = cb();\n    return collection[0];\n  });\n}\n\nexport type Reactive<T> = {\n  [K in keyof T]: T[K] extends Ref<infer U> ? U : T[K];\n};\n\nexport const _reactiveContent = <T>(obj: T) => {\n  return obj as Reactive<T>;\n};\n\nexport function _reactive<T extends object>(obj: T) {\n  return reactive(obj) as T;\n}\n\nexport type DeferredObject<T> = {\n  promise: Promise<T>;\n  resolve: Function;\n  reject: Function;\n};\nexport function defer<T>(): DeferredObject<T> {\n  const deferredObject: Record<string, any> = {};\n  const promise = new Promise((resolve, reject) => {\n    deferredObject.resolve = resolve;\n    deferredObject.reject = reject;\n  });\n  deferredObject.promise = promise as Promise<T>;\n\n  return deferredObject as DeferredObject<T>;\n}\n\nexport function printTask(task: Task<any, any>) {\n  let taskType = \"General\";\n\n  if (task._isDropping) {\n    taskType = \"Drop\";\n  }\n\n  if (task._isEnqueuing) {\n    taskType = \"Enqueue\";\n  }\n\n  if (task._isRestartable) {\n    taskType = \"Restartable\";\n  }\n\n  if (task._isKeepingLatest) {\n    taskType = \"KeepLatest\";\n  }\n\n  let header = `${taskType} Task`;\n\n  if (taskType !== \"General\") {\n    header = `${header} with maxConcurrency ${task._maxConcurrency}`;\n  }\n\n  const instanceRows = task._instances.map((instance) => {\n    let colorEmoji;\n\n    if (instance.isSuccessful) {\n      colorEmoji = \"ðŸ\";\n    } else if (instance.isRunning || instance.isEnqueued) {\n      colorEmoji = \"ðŸŠ\";\n    } else if (instance.isError || instance.isCanceled || instance.isDropped) {\n      colorEmoji = \"ðŸ”´\";\n    }\n\n    const { status, value, error } = instance;\n    return { status: `${colorEmoji} ${status}`, value, error };\n  });\n\n  console.log(`ðŸš¦ ${header}`);\n  console.table(instanceRows);\n}\n\nexport function timeout(time) {\n  if (process.env.NODE_ENV === \"test\") {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve) => setTimeout(resolve, time));\n}\n\nexport function getCancelToken<T extends { CancelToken: any }>(\n  axios: T,\n  signal: AbortSignalWithPromise\n) {\n  return new axios.CancelToken((cancel) => {\n    signal.pr.catch((reason) => {\n      if (reason === \"cancel\") {\n        cancel();\n      }\n    });\n  });\n}\n\nexport function useAsyncTask<T, U extends any[]>(\n  fn: (signal: AbortSignalWithPromise, ...params: U) => Promise<T>\n) {\n  return useTask(function* (signal, ...params: U) {\n    return fn(signal, ...params);\n  });\n}\n","import { computed, onUnmounted } from \"./utils/api\";\nimport createTaskInstance, {\n  TaskInstance,\n  ModifierOptions,\n} from \"./TaskInstance\";\nimport {\n  reachedMaxConcurrency,\n  cancelFirstRunning,\n  filteredInstances,\n  computedLength,\n  computedLastOf,\n  computedFirstOf,\n  _reactive,\n  _reactiveContent,\n  dropEnqueued,\n} from \"./utils/general\";\nimport { Resolved, TaskCb } from \"./types/index\";\n\nexport type Task<T, U extends any[]> = {\n  // Lifecycle state\n  isIdle: boolean;\n  isRunning: boolean;\n  isError: boolean;\n  performCount: number;\n\n  // Shortcuts to useful instances\n  last: TaskInstance<T> | undefined;\n  lastSuccessful: TaskInstance<T> | undefined;\n  firstEnqueued: TaskInstance<T> | undefined;\n\n  // Action Methods\n  cancelAll: () => void;\n  perform: (...params: U) => TaskInstance<T>;\n  clear: () => void;\n\n  // Modifiers\n  restartable: () => Task<T, U>;\n  drop: () => Task<T, U>;\n  enqueue: () => Task<T, U>;\n  keepLatest: () => Task<T, U>;\n  maxConcurrency: (number) => Task<T, U>;\n  _resetModifierFlags: () => void;\n\n  // Modifier flags\n  _maxConcurrency: number;\n  _isRestartable: boolean;\n  _isEnqueuing: boolean;\n  _isDropping: boolean;\n  _isKeepingLatest: boolean;\n\n  _hasConcurrency: boolean;\n\n  // Instances\n  _instances: TaskInstance<T>[];\n  _successfulInstances: readonly TaskInstance<T>[];\n  _runningInstances: readonly TaskInstance<T>[];\n  _activeInstances: readonly TaskInstance<T>[];\n  _enqueuedInstances: readonly TaskInstance<T>[];\n  _notDroppedInstances: readonly TaskInstance<T>[];\n};\n\nexport default function useTask<T, U extends any[]>(\n  cb: TaskCb<T, U>\n): Task<Resolved<T>, U> {\n  const content = _reactiveContent({\n    _isRestartable: false,\n    _isDropping: false,\n    _isEnqueuing: false,\n    _isKeepingLatest: false,\n    _maxConcurrency: 1, // this is used only when concurrency modifier is active (otherwise it has no effect)\n    _hasConcurrency: computed(\n      () =>\n        task._isRestartable ||\n        task._isDropping ||\n        task._isEnqueuing ||\n        task._isKeepingLatest\n    ),\n\n    isIdle: computed(() => !task.isRunning),\n    isRunning: computed(\n      () => !!task._instances.find((instance) => instance.isRunning)\n    ),\n    isError: computed(() => !!(task.last && task.last.isError)),\n\n    _instances: [],\n    // TODO: the filter + lastOf combo is concise and clear, but more efficient would be classic loop and iterating from the end (findLastIf macro)\n    _successfulInstances: filteredInstances(() => task, \"isSuccessful\"),\n    _runningInstances: filteredInstances(() => task, \"isRunning\"),\n    _enqueuedInstances: filteredInstances(() => task, \"isEnqueued\"),\n    _notDroppedInstances: filteredInstances(() => task, \"isNotDropped\"),\n    _activeInstances: filteredInstances(() => task, \"isActive\"),\n    performCount: computedLength(() => task._instances),\n    last: computedLastOf(() => task._notDroppedInstances),\n    lastSuccessful: computedLastOf(() => task._successfulInstances),\n    firstEnqueued: computedFirstOf(() => task._enqueuedInstances),\n\n    cancelAll() {\n      // Cancel all running and enqueued instances. Finished and dropped instances can't really be canceled.\n      task._instances.forEach(\n        (taskInstance) => {\n          try {\n            if (!taskInstance.isDropped && !taskInstance.isFinished) {\n              taskInstance.cancel();\n            }\n          } catch (e) {\n            if (e !== \"cancel\") {\n              throw e;\n            }\n          }\n        }\n      );\n    },\n\n    perform(...params) {\n      const modifiers: ModifierOptions = {\n        enqueue: false,\n        drop: false,\n      };\n\n      if (task._hasConcurrency && reachedMaxConcurrency(task)) {\n        if (task._isDropping) {\n          modifiers.drop = true;\n        }\n\n        if (task._isRestartable) {\n          cancelFirstRunning(task);\n        }\n\n        if (task._isKeepingLatest) {\n          dropEnqueued(task);\n        }\n\n        if (task._isEnqueuing || task._isKeepingLatest) {\n          modifiers.enqueue = true;\n        }\n      }\n\n      const onFinish = () => onTaskInstanceFinish(task);\n      const newInstance = createTaskInstance<T>(cb, params, {\n        modifiers,\n        onFinish,\n        id: task._instances.length + 1,\n      });\n      task._instances = [...task._instances, newInstance];\n      return newInstance;\n    },\n\n    clear() {\n      this.cancelAll();\n      this._instances = [];\n    },\n\n    restartable() {\n      task._resetModifierFlags();\n      task._isRestartable = true;\n      return task;\n    },\n\n    drop() {\n      task._resetModifierFlags();\n      task._isDropping = true;\n      return task;\n    },\n\n    enqueue() {\n      task._resetModifierFlags();\n      task._isEnqueuing = true;\n      return task;\n    },\n\n    keepLatest() {\n      task._resetModifierFlags();\n      task._isKeepingLatest = true;\n      return task;\n    },\n\n    _resetModifierFlags() {\n      task._isKeepingLatest = false;\n      task._isRestartable = false;\n      task._isEnqueuing = false;\n      task._isDropping = false;\n    },\n\n    maxConcurrency(number) {\n      task._maxConcurrency = number;\n      return task;\n    },\n  });\n  const task: Task<T, U> = _reactive(content);\n\n  onUnmounted(() => {\n    // check if there's instances still, Vue 3 might have done some cleanup already\n    if (task._instances) {\n      task.cancelAll();\n    }\n  });\n\n  // TODO: remove this type forcing\n  return task as Task<Resolved<T>, U>;\n}\n\nfunction onTaskInstanceFinish(task: Task<any, any>): void {\n  if (task._isEnqueuing || task._isKeepingLatest) {\n    const { firstEnqueued } = task;\n    if (firstEnqueued) {\n      firstEnqueued._run();\n    }\n  }\n\n  //TODO: run task.serialize() hook\n}\n","import CAF from \"caf\";\nimport { computed } from \"./utils/api\";\nimport { _reactive, _reactiveContent, DeferredObject, defer } from \"./utils/general\";\nimport {\n  AbortSignalWithPromise,\n  TaskCb,\n  onFulfilled,\n  onRejected,\n} from \"./types/index\";\n\nexport type TaskInstanceStatus =\n  | \"running\"\n  | \"enqueued\"\n  | \"canceled\"\n  | \"canceling\"\n  | \"dropped\"\n  | \"error\"\n  | \"success\";\nexport interface TaskInstance<T> extends PromiseLike<any> {\n  id: number;\n\n  // Lifecycle\n  hasStarted: boolean;\n  isRunning: boolean;\n  isActive: boolean;\n  isFinished: boolean;\n  isError: boolean;\n  isSuccessful: boolean;\n\n  isCanceling: boolean;\n  isCanceled: boolean;\n\n  isNotDropped: boolean;\n  status: TaskInstanceStatus;\n\n  _run: () => void;\n  cancel: () => void;\n  canceledOn: (signal: AbortSignalWithPromise) => TaskInstance<T>;\n  token?: Record<string, any>;\n\n  // Concurrency\n  isDropped: boolean;\n  isEnqueued: boolean;\n\n  // Data State\n  value: T | null;\n  error: any | null;\n\n  // Promise-like stuff\n  _shouldThrow: boolean;\n  _deferredObject: DeferredObject<T>;\n  _handled: boolean; // this is needed to set to true so that Vue does show error about unhandled rejection\n  then: (onfulfilled: onFulfilled<T>, onrejected?: onRejected) => Promise<any>;\n  catch: (onrejected?: onRejected) => any;\n  finally: (onfulfilled: () => any) => any;\n}\n\nexport interface ModifierOptions {\n  drop: boolean;\n  enqueue: boolean;\n}\n\nexport interface TaskInstanceOptions {\n  id: number;\n  modifiers: ModifierOptions;\n  onFinish: (taskInstance: TaskInstance<any>) => any;\n}\n\nexport default function createTaskInstance<T>(\n  cb: TaskCb<T, any>,\n  params: any[],\n  options: TaskInstanceOptions\n): TaskInstance<T> {\n  // Initial State\n  const content = _reactiveContent({\n    id: options.id,\n    isDropped: false,\n    isEnqueued: false,\n\n    hasStarted: false,\n    isRunning: false,\n    isFinished: false,\n    isCanceling: false,\n    isCanceled: computed(\n      () => taskInstance.isCanceling && taskInstance.isFinished\n    ),\n    isActive: computed(\n      () => taskInstance.isRunning && !taskInstance.isCanceling\n    ),\n    isSuccessful: false,\n    isNotDropped: computed(() => !taskInstance.isDropped),\n    isError: computed(() => !!taskInstance.error),\n    status: computed(() => {\n      const t = taskInstance;\n      const match = [\n        [t.isRunning, \"running\"],\n        [t.isEnqueued, \"enqueued\"],\n        [t.isCanceled, \"canceled\"],\n        [t.isCanceling, \"canceling\"],\n        [t.isDropped, \"dropped\"],\n        [t.isError, \"error\"],\n        [t.isSuccessful, \"success\"],\n      ].find(([cond]) => cond) as [boolean, TaskInstanceStatus];\n      return match && match[1];\n    }),\n\n    error: null,\n    value: null,\n    cancel() {\n      taskInstance.isCanceling = true;\n\n      if (taskInstance.isEnqueued) {\n        taskInstance.isFinished = true;\n      }\n\n      taskInstance.isEnqueued = false;\n\n      if (taskInstance.token) {\n        taskInstance.token.abort(\"cancel\");\n      }\n    },\n    canceledOn(signal: AbortSignalWithPromise) {\n      signal.pr.catch((e) => {\n        taskInstance.cancel();\n      });\n\n      return taskInstance;\n    },\n    _run() {\n      runTaskInstance(taskInstance, cb, params, options);\n    },\n\n    // PromiseLike things. These are necessary so that TaskInstance is `then`able and can be `await`ed\n\n    // Workaround for Vue not to scream because of unhandled rejection. Task is always \"handled\" because the error is saved to taskInstance.error.\n    _handled: true,\n    _deferredObject: defer<T>(),\n    _shouldThrow: false, // task throws only if it's used promise-like way (then, catch, await)\n    then(onFulfilled, onRejected) {\n      taskInstance._shouldThrow = true;\n      return taskInstance._deferredObject.promise.then(onFulfilled, onRejected);\n    },\n    catch(onRejected) {\n      taskInstance._shouldThrow = true;\n      return taskInstance._deferredObject.promise.catch(onRejected);\n    },\n    finally(cb) {\n      taskInstance._shouldThrow = true;\n      return taskInstance._deferredObject.promise.finally(cb);\n    },\n  });\n\n  // Create\n  const taskInstance: TaskInstance<T> = _reactive(content);\n\n  // Process = drop, enqueue or run right away!\n  const { modifiers } = options;\n  if (modifiers.drop) {\n    taskInstance.isDropped = true;\n  } else if (modifiers.enqueue) {\n    taskInstance.isEnqueued = true;\n  } else {\n    taskInstance._run();\n  }\n\n  return taskInstance;\n}\n\nfunction runTaskInstance<T>(\n  taskInstance: TaskInstance<any>,\n  cb: TaskCb<T, any>,\n  params: any[],\n  options: TaskInstanceOptions\n): void {\n  const token = new (CAF as any).cancelToken();\n  const cancelable = (CAF as any)(cb, token);\n  taskInstance.token = token;\n\n  taskInstance.hasStarted = true;\n  taskInstance.isRunning = true;\n  taskInstance.isEnqueued = false;\n\n  function setFinished() {\n    taskInstance.isRunning = false;\n    taskInstance.isFinished = true;\n  }\n\n  cancelable\n    .call(taskInstance, token, ...params)\n    .then((value) => {\n      taskInstance.value = value;\n      taskInstance.isSuccessful = true;\n\n      setFinished();\n      taskInstance._deferredObject.resolve(value);\n      options.onFinish(taskInstance);\n    })\n    .catch((e) => {\n      if (e !== \"cancel\") {\n        taskInstance.error = e;\n      }\n\n      setFinished();\n      if (taskInstance._shouldThrow) {\n        taskInstance._deferredObject.reject(e);\n      }\n      options.onFinish(taskInstance);\n    });\n}\n","import useTask, { Task } from \"./Task\";\n\nexport function usePipeTask<T, U extends any[]>(\n  firstTask: Task<any, U>,\n  ...restTasks: Task<any, any>[]\n): Task<T, U> {\n  return useTask(function*(signal, ...args: U) {\n    let result = yield firstTask.perform(...args).canceledOn(signal);\n    for (let task of restTasks) {\n      result = yield task.perform(result).canceledOn(signal);\n    }\n\n    return result;\n  });\n}\n\nexport function useParallelTask(...tasks: Task<any, any>[]): Task<any[], any> {\n  return useTask(function*(signal, ...args) {\n    const instances = tasks.map((task) => {\n      return task.perform(...args).canceledOn(signal);\n    });\n\n    const values = yield Promise.all(instances);\n    return values as any[];\n  });\n}\n\nexport function useSequentialTask<U extends any[]>(\n  ...tasks: Task<any, any>[]\n): Task<any, U> {\n  return useTask(function*(signal, ...args: U) {\n    const instances: any[] = [];\n    for (let task of tasks) {\n      instances.push((yield task.perform(...args).canceledOn(signal)) as any);\n    }\n\n    return instances;\n  });\n}\n","import {\n  onServerPrefetch,\n  getCurrentInstance,\n  computed,\n} from \"./api\";\nimport { TaskInstance } from \"../TaskInstance\";\nimport { Task } from \"../Task\";\n\nconst isServer = () => typeof window === \"undefined\";\n\nexport function reviveTaskInstance(instance: TaskInstance<any>) {\n  if (instance.isError) {\n    instance._deferredObject.promise = Promise.reject(instance.error);\n  } else {\n    instance._deferredObject.promise = Promise.resolve(instance.value);\n  }\n\n  instance.cancel = () => { };\n  instance.canceledOn = () => instance;\n  instance._run = () => { };\n  instance.then = (...params) =>\n    instance._deferredObject.promise.then(...params);\n  instance.catch = (...params) =>\n    instance._deferredObject.promise.catch(...params);\n  instance.finally = (...params) =>\n    instance._deferredObject.promise.finally(...params);\n}\n\nexport function useTaskPrefetch<T>(\n  key: string,\n  task: Task<T, any>\n): TaskInstance<T> {\n  /* Server */\n  if (isServer()) {\n    // perform, add to prefetch, add to ssrContext\n    const taskInstance = task.perform();\n    onServerPrefetch(async () => {\n      try {\n        await taskInstance;\n        saveTaskToNuxtState(key, task);\n      } catch (e) {\n        // no need for extra handling\n      }\n    });\n    return taskInstance;\n  }\n\n  /* Client */\n  const [last] = reviveTaskInstances(key, task).reverse();\n\n  if (last) {\n    return last;\n  } else {\n    return task.perform();\n  }\n}\n\nfunction saveTaskToNuxtState(key: string, task: Task<any, any>) {\n  const { $root } = getCurrentInstance() as any;\n  const nuxtState = $root && $root.context && $root.context.nuxtState;\n  if (!nuxtState) {\n    throw new Error(\"Could not access $root.context.nuxtState\");\n  }\n\n  if (!nuxtState.vueConcurrency) {\n    nuxtState.vueConcurrency = {};\n  }\n\n  nuxtState.vueConcurrency[key] = computed(() => ({\n    instances: task._instances,\n  }));\n}\n\nfunction reviveTaskInstances(key: string, task: Task<any, any>) {\n  const taskCache = getTaskFromContext(key);\n  if (taskCache) {\n    task._instances = taskCache.instances || [];\n    task._instances.forEach(reviveTaskInstance);\n    deleteTaskCache(key);\n  }\n\n  return task._instances;\n}\n\nfunction getNuxtData() {\n  return (window as any).__NUXT__;\n}\n\nfunction getTaskFromContext(key) {\n  if (!getNuxtData()) {\n    throw Error(`Could not access  window.__NUXT__`);\n  }\n\n  return getNuxtData().vueConcurrency[key].value;\n}\n\nfunction deleteTaskCache(key) {\n  const nuxtData = getNuxtData();\n  delete nuxtData.vueConcurrency[key];\n}\n\nexport function useSSRPersistance(key: string, task: Task<any, any>) {\n  if (isServer()) {\n    saveTaskToNuxtState(key, task);\n    return;\n  }\n\n  reviveTaskInstances(key, task);\n}\n","export { ref, reactive, onMounted, onUnmounted, defineComponent, computed, Ref, watchEffect, watch, getCurrentInstance } from \"vue3\";\n\n// onServerPrefetch is not supported in Vue 3 so far\nexport const onServerPrefetch = (cb: () => any) => {\n  throw new Error('vue-concurrency SSR features are not supported in Vue 3 so far');\n};\n","import { Task } from \"./Task\";\nimport { reactive, computed } from \"./utils/api\";\n\nexport interface TaskState {\n  isRunning: boolean;\n  isIdle: boolean;\n}\n\nexport type TaskGroup<U extends Record<string, Task<any, any>>> = TaskState & U;\n\nexport default function useTaskGroup<U extends Record<string, Task<any, any>>>(\n  taskMap: U\n): TaskGroup<U> {\n  const taskArray = Object.values(taskMap);\n  const taskGroup = reactive({\n    isRunning: computed(() => !!taskArray.find((task) => task.isRunning)),\n    isIdle: computed(() => !taskGroup.isRunning),\n    ...taskMap,\n  });\n\n  return taskGroup;\n}\n"],"names":["waitForValue","cb","Promise","resolve","stop","watch","value","immediate","filteredInstances","key","computed","filter","item","computedFilterBy","_instances","computedLength","length","computedLastOf","collection","computedFirstOf","_reactive","obj","reactive","defer","deferredObject","promise","reject","printTask","task","taskType","_isDropping","_isEnqueuing","_isRestartable","_isKeepingLatest","header","_maxConcurrency","instanceRows","map","instance","colorEmoji","isSuccessful","isRunning","isEnqueued","isError","isCanceled","isDropped","status","error","console","log","table","timeout","time","process","env","NODE_ENV","setTimeout","getCancelToken","axios","signal","CancelToken","cancel","pr","catch","reason","useAsyncTask","fn","useTask","params","_hasConcurrency","isIdle","find","last","_successfulInstances","_runningInstances","_enqueuedInstances","_notDroppedInstances","_activeInstances","performCount","lastSuccessful","firstEnqueued","cancelAll","forEach","taskInstance","isFinished","e","perform","modifiers","enqueue","drop","reachedMaxConcurrency","firstRunningInstance","cancelFirstRunning","dropEnqueued","newInstance","options","id","hasStarted","isCanceling","isActive","isNotDropped","match","cond","token","abort","canceledOn","_run","CAF","cancelToken","cancelable","setFinished","call","then","_deferredObject","onFinish","_shouldThrow","runTaskInstance","_handled","onFulfilled","onRejected","finally","createTaskInstance","onTaskInstanceFinish","clear","this","restartable","_resetModifierFlags","keepLatest","maxConcurrency","number","onUnmounted","usePipeTask","firstTask","restTasks","args","result","useParallelTask","tasks","instances","all","useSequentialTask","push","isServer","window","reviveTaskInstance","useTaskPrefetch","Error","onServerPrefetch","reviveTaskInstances","reverse","taskCache","getNuxtData","vueConcurrency","getTaskFromContext","deleteTaskCache","__NUXT__","useSSRPersistance","$root","getCurrentInstance","nuxtState","context","saveTaskToNuxtState","useTaskGroup","taskMap","taskArray","Object","values","taskGroup"],"mappings":"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"}