import{computed as e,reactive as n,watch as r,onUnmounted as s,getCurrentInstance as i}from"vue";import t from"caf";function c(e){return new Promise(n=>{const s=r(e,e=>{null!=e&&(n(e),s&&s())},{immediate:!0})})}function o(n,r){return r?function(n,r,s){return e(()=>n().filter(e=>e[r]))}(()=>n()._instances,r):e(()=>[])}function u(n){return e(()=>n().length)}function a(n){return e(()=>{const e=n();return e[e.length-1]})}function l(n){return e(()=>n()[0])}function d(e){return n(e)}function f(){const e={},n=new Promise((n,r)=>{e.resolve=n,e.reject=r});return e.promise=n,e}function _(e){let n="General";e._isDropping&&(n="Drop"),e._isEnqueuing&&(n="Enqueue"),e._isRestartable&&(n="Restartable"),e._isKeepingLatest&&(n="KeepLatest");let r=n+" Task";"General"!==n&&(r=`${r} with maxConcurrency ${e._maxConcurrency}`);const s=e._instances.map(e=>{let n;e.isSuccessful?n="🍏":e.isRunning||e.isEnqueued?n="🍊":(e.isError||e.isCanceled||e.isDropped)&&(n="🔴");const{status:r,value:s,error:i}=e;return{status:`${n} ${r}`,value:s,error:i}});console.log("🚦 "+r),console.table(s)}function p(e){return"test"===process.env.NODE_ENV?Promise.resolve():new Promise(n=>setTimeout(n,e))}function g(e,n){return new e.CancelToken(e=>{n.pr.catch(n=>{"cancel"===n&&e()})})}function h(e){return m(function*(n,...r){return e(n,...r)})}function m(n){const r=d({_isRestartable:!1,_isDropping:!1,_isEnqueuing:!1,_isKeepingLatest:!1,_maxConcurrency:1,_hasConcurrency:e(()=>r._isRestartable||r._isDropping||r._isEnqueuing||r._isKeepingLatest),isIdle:e(()=>!r.isRunning),isRunning:e(()=>!!r._instances.find(e=>e.isRunning)),isError:e(()=>!(!r.last||!r.last.isError)),_instances:[],_successfulInstances:o(()=>r,"isSuccessful"),_runningInstances:o(()=>r,"isRunning"),_enqueuedInstances:o(()=>r,"isEnqueued"),_notDroppedInstances:o(()=>r,"isNotDropped"),_activeInstances:o(()=>r,"isActive"),performCount:u(()=>r._instances),last:a(()=>r._notDroppedInstances),lastSuccessful:a(()=>r._successfulInstances),firstEnqueued:l(()=>r._enqueuedInstances),cancelAll(){r._instances.forEach(e=>{try{e.isDropped||e.isFinished||e.cancel()}catch(e){if("cancel"!==e)throw e}})},perform(...s){const i={enqueue:!1,drop:!1};r._hasConcurrency&&(e=>e._runningInstances.length>=e._maxConcurrency)(r)&&(r._isDropping&&(i.drop=!0),r._isRestartable&&(e=>{const n=e._activeInstances[0];n&&n.cancel()})(r),r._isKeepingLatest&&(e=>{e._enqueuedInstances.forEach(e=>{e.isEnqueued=!1,e.isDropped=!0})})(r),(r._isEnqueuing||r._isKeepingLatest)&&(i.enqueue=!0));const c=function(n,r,s){const i=d({id:s.id,isDropped:!1,isEnqueued:!1,hasStarted:!1,isRunning:!1,isFinished:!1,isCanceling:!1,isCanceled:e(()=>i.isCanceling&&i.isFinished),isActive:e(()=>i.isRunning&&!i.isCanceling),isSuccessful:!1,isNotDropped:e(()=>!i.isDropped),isError:e(()=>!!i.error),status:e(()=>{const e=[[i.isRunning,"running"],[i.isEnqueued,"enqueued"],[i.isCanceled,"canceled"],[i.isCanceling,"canceling"],[i.isDropped,"dropped"],[i.isError,"error"],[i.isSuccessful,"success"]].find(([e])=>e);return e&&e[1]}),error:null,value:null,cancel(){i.isCanceling=!0,i.isEnqueued&&(i.isFinished=!0),i.isEnqueued=!1,i.token&&i.token.abort("cancel")},canceledOn:e=>(e.pr.catch(e=>{i.cancel()}),i),_run(){!function(e,n,r,s){const i=new t.cancelToken,c=t(n,i);function o(){e.isRunning=!1,e.isFinished=!0}e.token=i,e.hasStarted=!0,e.isRunning=!0,e.isEnqueued=!1,c.call(e,i,...r).then(n=>{e.value=n,e.isSuccessful=!0,o(),e._deferredObject.resolve(n),s.onFinish(e)}).catch(n=>{"cancel"!==n&&(e.error=n),o(),e._shouldThrow&&e._deferredObject.reject(n),s.onFinish(e)})}(i,n,r,s)},_handled:!0,_deferredObject:f(),_shouldThrow:!1,then:(e,n)=>(i._shouldThrow=!0,i._deferredObject.promise.then(e,n)),catch:e=>(i._shouldThrow=!0,i._deferredObject.promise.catch(e)),finally:e=>(i._shouldThrow=!0,i._deferredObject.promise.finally(e))}),{modifiers:c}=s;return c.drop?i.isDropped=!0:c.enqueue?i.isEnqueued=!0:i._run(),i}(n,s,{modifiers:i,onFinish:()=>function(e){if(e._isEnqueuing||e._isKeepingLatest){const{firstEnqueued:n}=e;n&&n._run()}}(r),id:r._instances.length+1});return r._instances=[...r._instances,c],c},clear(){this.cancelAll(),this._instances=[]},restartable:()=>(r._resetModifierFlags(),r._isRestartable=!0,r),drop:()=>(r._resetModifierFlags(),r._isDropping=!0,r),enqueue:()=>(r._resetModifierFlags(),r._isEnqueuing=!0,r),keepLatest:()=>(r._resetModifierFlags(),r._isKeepingLatest=!0,r),_resetModifierFlags(){r._isKeepingLatest=!1,r._isRestartable=!1,r._isEnqueuing=!1,r._isDropping=!1},maxConcurrency:e=>(r._maxConcurrency=e,r)});return s(()=>{r._instances&&r.cancelAll()}),r}function E(e,...n){return m(function*(r,...s){let i=yield e.perform(...s).canceledOn(r);for(let e of n)i=yield e.perform(i).canceledOn(r);return i})}function q(...e){return m(function*(n,...r){const s=e.map(e=>e.perform(...r).canceledOn(n));return yield Promise.all(s)})}function C(...e){return m(function*(n,...r){const s=[];for(let i of e)s.push(yield i.perform(...r).canceledOn(n));return s})}const v=()=>"undefined"==typeof window;function y(e){e._deferredObject.promise=e.isError?Promise.reject(e.error):Promise.resolve(e.value),e.cancel=()=>{},e.canceledOn=()=>e,e._run=()=>{},e.then=(...n)=>e._deferredObject.promise.then(...n),e.catch=(...n)=>e._deferredObject.promise.catch(...n),e.finally=(...n)=>e._deferredObject.promise.finally(...n)}function w(e,n){if(v()){const e=n.perform();return(e=>{throw new Error("vue-concurrency SSR features are not supported in Vue 3 so far")})(),e}const[r]=b(e,n).reverse();return r||n.perform()}function b(e,n){const r=function(e){if(!R())throw Error("Could not access  window.__NUXT__");return R().vueConcurrency[e].value}(e);return r&&(n._instances=r.instances||[],n._instances.forEach(y),function(e){delete R().vueConcurrency[e]}(e)),n._instances}function R(){return window.__NUXT__}function D(n,r){v()?function(n,r){const{$root:s}=i(),t=s&&s.context&&s.context.nuxtState;if(!t)throw new Error("Could not access $root.context.nuxtState");t.vueConcurrency||(t.vueConcurrency={}),t.vueConcurrency[n]=e(()=>({instances:r._instances}))}(n,r):b(n,r)}function O(r){const s=Object.values(r),i=n({isRunning:e(()=>!!s.find(e=>e.isRunning)),isIdle:e(()=>!i.isRunning),...r});return i}export{g as getCancelToken,_ as printTask,p as timeout,h as useAsyncTask,q as useParallelTask,E as usePipeTask,D as useSSRPersistance,C as useSequentialTask,m as useTask,O as useTaskGroup,w as useTaskPrefetch,c as waitForValue};
//# sourceMappingURL=vue-concurrency.modern.js.map
